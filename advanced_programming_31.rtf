{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf610
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red89\green138\blue67;\red23\green23\blue23;\red202\green202\blue202;
\red183\green111\blue179;\red70\green137\blue204;\red194\green126\blue101;\red67\green192\blue160;\red212\green214\blue154;
\red167\green197\blue152;\red140\green211\blue254;}
{\*\expandedcolortbl;;\cssrgb\c41569\c60000\c33333;\cssrgb\c11765\c11765\c11765;\cssrgb\c83137\c83137\c83137;
\cssrgb\c77255\c52549\c75294;\cssrgb\c33725\c61176\c83922;\cssrgb\c80784\c56863\c47059;\cssrgb\c30588\c78824\c69020;\cssrgb\c86275\c86275\c66667;
\cssrgb\c70980\c80784\c65882;\cssrgb\c61176\c86275\c99608;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl360\partightenfactor0

\f0\fs24 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 // Questions: \cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // 1) is it normal to write things in one line, such as in the "stack.h"-file? \cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // 2) where to put the indentation of public and private? \cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // 3) why is in "stack.h" the variable "count" not initialized by "int count" instead? \cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // 4) the "void close()" function that is called by the destructor does not seem necessary, because there are no memory leaks. How to remove count and when in the code is it removed?\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // 5) how does this new way work with calling constructors in the beginning and is this now how things are always called? \cf4 \cb1 \strokec4 \
\
\
\pard\pardeftab720\sl360\partightenfactor0
\cf5 \cb3 \strokec5 #include\cf6 \strokec6  \cf7 \strokec7 <iostream>\cf6 \strokec6  \cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 #include\cf6 \strokec6  \cf7 \strokec7 "stack.h"\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl360\partightenfactor0
\cf4 \cb3 using \cf6 \strokec6 namespace\cf4 \strokec4  \cf8 \strokec8 std\cf4 \strokec4  ;\cb1 \
\
\
\pard\pardeftab720\sl360\partightenfactor0
\cf6 \cb3 \strokec6 int\cf4 \strokec4  \cf9 \strokec9 main\cf4 \strokec4 () \{\cb1 \
\pard\pardeftab720\sl360\partightenfactor0
\cf4 \cb3   \cb1 \
\cb3     Stack s ;\cb1 \
\pard\pardeftab720\sl360\partightenfactor0
\cf2 \cb3 \strokec2     //   s.init() ; // initialize Stack, but not necessary after the constructor was made \cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl360\partightenfactor0
\cf4 \cb3   \cb1 \
\pard\pardeftab720\sl360\partightenfactor0
\cf2 \cb3 \strokec2     // Write doubles into Stack\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl360\partightenfactor0
\cf4 \cb3     \cf6 \strokec6 int\cf4 \strokec4  i ;\cb1 \
\cb3     \cf5 \strokec5 for\cf4 \strokec4  (i=\cf10 \strokec10 0\cf4 \strokec4  ; i<\cf10 \strokec10 100\cf4 \strokec4  ; i++) \{\cb1 \
\cb3         cout << \cf7 \strokec7 "pushing value "\cf4 \strokec4  << i*i << \cf7 \strokec7 " in stack"\cf4 \strokec4  << endl ;\cb1 \
\cb3         \cf11 \strokec11 s\cf4 \strokec4 .\cf9 \strokec9 push\cf4 \strokec4 (i*i) ;\cb1 \
\cb3     \}\cb1 \
\
\pard\pardeftab720\sl360\partightenfactor0
\cf2 \cb3 \strokec2     // Count doubles in fifo\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl360\partightenfactor0
\cf4 \cb3     cout << \cf11 \strokec11 s\cf4 \strokec4 .\cf9 \strokec9 nitems\cf4 \strokec4 () << \cf7 \strokec7 " values in stack"\cf4 \strokec4  << endl ;\cb1 \
\cb3     \cf11 \strokec11 s\cf4 \strokec4 .\cf9 \strokec9 inspect\cf4 \strokec4 () ;\cf2 \strokec2  // inspect the stack when it is full\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\sl360\partightenfactor0
\cf2 \cb3 \strokec2     // Read doubles back from fifo\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl360\partightenfactor0
\cf4 \cb3     \cf5 \strokec5 while\cf4 \strokec4  (!\cf11 \strokec11 s\cf4 \strokec4 .\cf9 \strokec9 empty\cf4 \strokec4 ()) \{\cb1 \
\cb3         \cf6 \strokec6 double\cf4 \strokec4  val = \cf11 \strokec11 s\cf4 \strokec4 .\cf9 \strokec9 pop\cf4 \strokec4 () ;\cb1 \
\cb3         cout << \cf7 \strokec7 "popping value "\cf4 \strokec4  << val << \cf7 \strokec7 " from stack"\cf4 \strokec4  << endl ;\cb1 \
\cb3         \cf5 \strokec5 if\cf4 \strokec4  (\cf11 \strokec11 s\cf4 \strokec4 .\cf9 \strokec9 nitems\cf4 \strokec4 ()==\cf10 \strokec10 50\cf4 \strokec4 ) \{\cb1 \
\cb3             \cf11 \strokec11 s\cf4 \strokec4 .\cf9 \strokec9 inspect\cf4 \strokec4 () ;\cf2 \strokec2  // inspect the stack when it contains 50 items\cf4 \cb1 \strokec4 \
\cb3         \}\cf2 \strokec2   // look at stack after values are "popped out"\cf4 \cb1 \strokec4 \
\cb3     \}\cb1 \
\
\cb3     \cf11 \strokec11 s\cf4 \strokec4 .\cf9 \strokec9 inspect\cf4 \strokec4 () ;\cf2 \strokec2  // insepct stack when it is empty \cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 return\cf4 \strokec4  \cf10 \strokec10 0\cf4 \strokec4  ;\cb1 \
\cb3 \}\cb1 \
\
\pard\pardeftab720\sl360\partightenfactor0
\cf2 \cb3 \strokec2 // To run the files:\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //      g++ -c stack.cc\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //      g++ -c main.cc\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //      g++ -o ouput main.o stack.o \cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //      ./output\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // \cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // To switch between git versions:\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //      git checkout t_ex31\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //      git checkout -b b_ex31\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //      (edit, git add, git commit)\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //      git checkout master\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //      git merge b_ex31 \
\
\
\
\pard\pardeftab720\sl360\partightenfactor0
\cf5 \strokec5 #include\cf6 \strokec6  \cf7 \strokec7 <iostream>\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 #include\cf6 \strokec6  \cf7 \strokec7 "stack.h"\cf4 \cb1 \strokec4 \
\cb3 using \cf6 \strokec6 namespace\cf4 \strokec4  \cf8 \strokec8 std\cf4 \strokec4  ;\cb1 \
\
\
\
\cf6 \cb3 \strokec6 void\cf4 \strokec4  \cf8 \strokec8 Stack\cf4 \strokec4 ::\cf9 \strokec9 push\cf4 \strokec4 (\cf6 \strokec6 double\cf4 \strokec4  \cf11 \strokec11 c\cf4 \strokec4 ) \{ \cb1 \
\cb3     \cf5 \strokec5 if\cf4 \strokec4  (\cf9 \strokec9 full\cf4 \strokec4 ()) \{ \cb1 \
\cb3         cout << \cf7 \strokec7 "Stack::push() Error: stack is full"\cf4 \strokec4  << endl ; \cb1 \
\cb3         \cf5 \strokec5 return\cf4 \strokec4  ; \cb1 \
\cb3     \} \cb1 \
\cb3     \cf11 \strokec11 s\cf4 \strokec4 [count++] = c ; \cb1 \
\cb3 \}\cb1 \
\
\cf6 \cb3 \strokec6 double\cf4 \strokec4  \cf8 \strokec8 Stack\cf4 \strokec4 ::\cf9 \strokec9 pop\cf4 \strokec4 () \{ \cb1 \
\cb3     \cf5 \strokec5 if\cf4 \strokec4  (\cf9 \strokec9 empty\cf4 \strokec4 ()) \{\cb1 \
\cb3         cout << \cf7 \strokec7 "Stack::pop() Error: stack is empty"\cf4 \strokec4  << endl ;\cb1 \
\cb3         \cf5 \strokec5 return\cf4 \strokec4  \cf10 \strokec10 0\cf4 \strokec4  ;\cb1 \
\cb3     \}    \cb1 \
\cb3     \cf5 \strokec5 return\cf4 \strokec4  \cf11 \strokec11 s\cf4 \strokec4 [--count] ;\cb1 \
\cb3 \}\cb1 \
\
\cf6 \cb3 \strokec6 void\cf4 \strokec4  \cf8 \strokec8 Stack\cf4 \strokec4 ::\cf9 \strokec9 inspect\cf4 \strokec4 () \{\cf2 \strokec2  // prints the positions and values in Stack \cf4 \cb1 \strokec4 \
\cb3     \cf5 \strokec5 if\cf4 \strokec4  (count == \cf10 \strokec10 0\cf4 \strokec4 ) \{\cb1 \
\cb3         cout << \cf7 \strokec7 "Stack is empty"\cf4 \strokec4  << endl ;\cb1 \
\cb3     \} \cf5 \strokec5 else\cf4 \strokec4  \{\cb1 \
\cb3         \cf5 \strokec5 for\cf4 \strokec4  (\cf6 \strokec6 int\cf4 \strokec4  i=\cf10 \strokec10 0\cf4 \strokec4 ; i<count; i++) \{\cb1 \
\cb3             cout << i << \cf7 \strokec7 " "\cf4 \strokec4  << \cf11 \strokec11 s\cf4 \strokec4 [i] << endl ;\cb1 \
\cb3         \}\cb1 \
\cb3     \}\cb1 \
\cb3 \}\cb1 \
\
\
\
\pard\pardeftab720\sl360\partightenfactor0
\cf4 \
\pard\pardeftab720\sl360\partightenfactor0
\cf5 \cb3 \strokec5 #ifndef\cf6 \strokec6  STACK\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 #define\cf6 \strokec6  STACK\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\sl360\partightenfactor0
\cf6 \cb3 \strokec6 const\cf4 \strokec4  \cf6 \strokec6 int\cf4 \strokec4  LEN = \cf10 \strokec10 80\cf4 \strokec4  ;\cf2 \strokec2  // default stack length\cf4 \cb1 \strokec4 \
\
\cf6 \cb3 \strokec6 class\cf4 \strokec4  \cf8 \strokec8 Stack\cf4 \strokec4  \{\cf2 \strokec2      // a class is by default private while a struct is by default public \cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\sl360\partightenfactor0
\cf4 \cb3   \cf6 \strokec6 public:\cf2 \strokec2    // Interface (=public normally)\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl360\partightenfactor0
\cf2 \cb3 \strokec2     // void init() \{ count = 0 ; \} // not public any more, because of constructor\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl360\partightenfactor0
\cf4 \cb3     \cf9 \strokec9 Stack\cf4 \strokec4 () \{ \cf9 \strokec9 init\cf4 \strokec4 () ; \}\cf2 \strokec2  // constructor --> this self initializes the function\cf4 \cb1 \strokec4 \
\cb3     \cf9 \strokec9 ~Stack\cf4 \strokec4 () \{ \cf9 \strokec9 close\cf4 \strokec4 () ; \}\cf2 \strokec2  // destructor --> removes variables that were initialized\cf4 \cb1 \strokec4 \
\cb3     \cf6 \strokec6 int\cf4 \strokec4  \cf9 \strokec9 nitems\cf4 \strokec4 () \{ \cf5 \strokec5 return\cf4 \strokec4  count ; \}\cb1 \
\cb3     \cf6 \strokec6 bool\cf4 \strokec4  \cf9 \strokec9 full\cf4 \strokec4 () \{ \cf5 \strokec5 return\cf4 \strokec4  (count==LEN) ; \}\cb1 \
\cb3     \cf6 \strokec6 bool\cf4 \strokec4  \cf9 \strokec9 empty\cf4 \strokec4 () \{ \cf5 \strokec5 return\cf4 \strokec4  (count==\cf10 \strokec10 0\cf4 \strokec4 ) ; \}\cb1 \
\
\cb3     \cf6 \strokec6 void\cf4 \strokec4  \cf9 \strokec9 push\cf4 \strokec4 (\cf6 \strokec6 double\cf4 \strokec4  \cf11 \strokec11 c\cf4 \strokec4 ) ;\cb1 \
\cb3     \cf6 \strokec6 double\cf4 \strokec4  \cf9 \strokec9 pop\cf4 \strokec4 () ;\cb1 \
\cb3     \cf6 \strokec6 void\cf4 \strokec4  \cf9 \strokec9 inspect\cf4 \strokec4 () ;\cb1 \
\
\cb3   \cf6 \strokec6 private:\cf2 \strokec2   // Implementation (=private normally)\cf4 \cb1 \strokec4 \
\cb3     \cf6 \strokec6 void\cf4 \strokec4  \cf9 \strokec9 init\cf4 \strokec4 () \{ count = \cf10 \strokec10 0\cf4 \strokec4  ; \cf8 \strokec8 std\cf4 \strokec4 ::cout << \cf7 \strokec7 "initialized by constructor"\cf4 \strokec4  << \cf8 \strokec8 std\cf4 \strokec4 ::endl ;\}\cf2 \strokec2  // after the constructor was added, init() is now private, so there can only be self initialization\cf4 \cb1 \strokec4 \
\cb3     \cf6 \strokec6 void\cf4 \strokec4  \cf9 \strokec9 close\cf4 \strokec4 () \{ \cf8 \strokec8 std\cf4 \strokec4 ::cout << \cf7 \strokec7 "closed by destructor"\cf4 \strokec4  << \cf8 \strokec8 std\cf4 \strokec4 ::endl ; \}\cf2 \strokec2  // how to remove count and when is removed\cf4 \cb1 \strokec4 \
\cb3     \cf6 \strokec6 double\cf4 \strokec4  \cf11 \strokec11 s\cf4 \strokec4 [LEN] ;\cb1 \
\cb3     \cf6 \strokec6 int\cf4 \strokec4  count ;\cf2 \strokec2  // --> why can you put the definition of count after when it is used? \cf4 \cb1 \strokec4 \
\cb3 \} ;\cb1 \
\
\pard\pardeftab720\sl360\partightenfactor0
\cf5 \cb3 \strokec5 #endif\cf4 \cb1 \strokec4 \
\
\
}